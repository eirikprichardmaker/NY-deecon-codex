# src/ingest_fundamentals_history.py
from __future__ import annotations

import argparse
import json
import os
import random
import time
from collections import Counter
from pathlib import Path
from typing import Any, Dict, Iterable, List, Tuple

import pandas as pd
import requests
from dotenv import load_dotenv
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

load_dotenv(override=True)

BASE_URL = "https://apiservice.borsdata.se/v1"

# ---------------- HTTP/JSON DEBUG ----------------
DEBUG_HTTP = os.getenv("DEBUG_HTTP", "0") == "1"
_HTTP_STATUS_COUNTS: Counter = Counter()
_HTTP_ERROR_SAMPLES: List[dict] = []
_HTTP_OK_SAMPLES: List[dict] = []


def _safe_url(u: str) -> str:
    # fjern authKey/apikey fra URL i logger
    for k in ("authKey=", "apikey=", "apiKey="):
        if k in u:
            return u.split(k)[0] + k + "***"
    return u

def _verify_tls() -> bool:
    return os.environ.get("BORSDATA_TLS_INSECURE", "").strip() != "1"



def _record_http(r: requests.Response) -> None:
    sc = getattr(r, "status_code", None)
    _HTTP_STATUS_COUNTS[sc] += 1

    if not DEBUG_HTTP:
        return

    if sc != 200:
        if len(_HTTP_ERROR_SAMPLES) < 5:
            try:
                txt = r.text or ""
            except Exception:
                txt = ""
            _HTTP_ERROR_SAMPLES.append(
                {
                    "status": sc,
                    "url": _safe_url(str(getattr(r, "url", ""))),
                    "text_head": (txt[:300].replace("\n", " ") if isinstance(txt, str) else ""),
                }
            )
        return

    # 200 sample: JSON-type/keys (maks 3)
    if len(_HTTP_OK_SAMPLES) < 3:
        try:
            j = r.json()
            if isinstance(j, dict):
                _HTTP_OK_SAMPLES.append({"type": "dict", "keys": list(j.keys())[:30]})
            elif isinstance(j, list):
                _HTTP_OK_SAMPLES.append({"type": "list", "len": len(j)})
            else:
                _HTTP_OK_SAMPLES.append({"type": str(type(j))})
        except Exception as e:
            _HTTP_OK_SAMPLES.append({"type": "json_error", "err": str(e)[:200]})


def _attach_http_debug_to_meta(meta: dict) -> dict:
    meta["http_status_counts"] = dict(_HTTP_STATUS_COUNTS)
    meta["http_error_samples"] = _HTTP_ERROR_SAMPLES
    meta["http_ok_samples"] = _HTTP_OK_SAMPLES
    return meta


# ---------------- KPI SPECS ----------------
KPI_SPECS_FULL = [
    {"name": "roic", "kpi_id": 37, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "ev_ebit", "kpi_id": 10, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "netdebt_ebitda", "kpi_id": 42, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "gross_profit_m", "kpi_id": 135, "reporttypes": ["year", "r12", "quarter"], "pricetype": "mean"},
    {"name": "total_assets_m", "kpi_id": 57, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "fcf_m", "kpi_id": 63, "reporttypes": ["year", "r12", "quarter"], "pricetype": "mean"},
    {"name": "mcap_m", "kpi_id": 50, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "ev_m", "kpi_id": 49, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "netdebt_m", "kpi_id": 60, "reporttypes": ["year", "r12"], "pricetype": "mean"},
    {"name": "ebit_m", "kpi_id": 55, "reporttypes": ["year", "r12", "quarter"], "pricetype": "mean"},
    {"name": "ebitda_m", "kpi_id": 54, "reporttypes": ["year", "r12", "quarter"], "pricetype": "mean"},
]
KPI_SPECS_CORE = [KPI_SPECS_FULL[0], KPI_SPECS_FULL[1], KPI_SPECS_FULL[2]]


def _auth_key() -> str:
    key = (
        os.getenv("BORSDATA_AUTHKEY")
        or os.getenv("BORSDATA_API_KEY")
        or os.getenv("BORSDATA_KEY")
        or ""
    ).strip()
    if not key:
        raise RuntimeError(
            "Mangler Borsdata API-key. Sett env var BORSDATA_AUTHKEY (evt BORSDATA_API_KEY)."
        )
    return key


def _make_session() -> requests.Session:
    s = requests.Session()
    retry = Retry(
        total=10,
        connect=10,
        read=10,
        status=10,
        backoff_factor=1.0,
        status_forcelist=(429, 500, 502, 503, 504),
        allowed_methods=frozenset(["GET"]),
        raise_on_status=False,
    )
    adapter = HTTPAdapter(max_retries=retry, pool_connections=50, pool_maxsize=50)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    return s


_SESSION = _make_session()


def _chunked(xs: List[Any], n: int) -> Iterable[List[Any]]:
    for i in range(0, len(xs), n):
        yield xs[i : i + n]


def _get_json(url: str, params: Dict[str, Any], timeout: int, max_retries: int) -> Any:
    """
    Robust GET:
    - Retry adapter håndterer 429/5xx
    - Wrapper håndterer Connection/SSL/Timeout med backoff + jitter
    - DEBUG_HTTP: samler status counts + samples
    """
    backoff = 1.0
    last_exc: Exception | None = None

    for _attempt in range(1, max_retries + 1):
        try:
            r = _SESSION.get(url, params=params, timeout=timeout, verify=_verify_tls())
            _record_http(r)

            if r.status_code >= 400:
                if r.status_code in (401, 403):
                    # fail fast
                    r.raise_for_status()

                if r.status_code in (429, 500, 502, 503, 504):
                    time.sleep(backoff + random.random())
                    backoff = min(backoff * 2, 30)
                    continue

                r.raise_for_status()

            return r.json()

        except (requests.exceptions.ConnectionError, requests.exceptions.SSLError, requests.exceptions.Timeout) as e:
            last_exc = e
            time.sleep(backoff + random.random())
            backoff = min(backoff * 2, 30)
            continue

    if last_exc:
        raise last_exc
    raise RuntimeError("HTTP error uten exception (uventet)")


def _read_tickers_csv(path: Path) -> pd.DataFrame:
    df = pd.read_csv(path)
    cols = set(df.columns)

    if "yahoo_ticker" not in cols:
        raise ValueError(f"{path}: må ha kolonne yahoo_ticker")

    if "ins_id" not in cols and "ticker" not in cols:
        raise ValueError(
            f"{path}: må ha minst én av kolonnene ins_id eller ticker (i tillegg til yahoo_ticker)."
        )

    for c in ["ticker", "yahoo_ticker", "country", "sector", "company"]:
        if c in df.columns:
            df[c] = df[c].astype(str).str.strip()

    if "ins_id" in df.columns:
        df["ins_id"] = pd.to_numeric(df["ins_id"], errors="coerce")

    df = df[df["yahoo_ticker"].astype(str).str.strip().ne("")].copy()
    if "ticker" in df.columns:
        df = df[df["ticker"].astype(str).str.strip().ne("")].copy()

    for col in ["country", "sector", "company"]:
        if col not in df.columns:
            df[col] = ""

    keep = ["yahoo_ticker"]
    if "ticker" in df.columns:
        keep.append("ticker")
    if "ins_id" in df.columns:
        keep.append("ins_id")

    df = df.drop_duplicates(subset=keep)
    return df


def _fetch_instruments_map(authkey: str, timeout: int, max_retries: int) -> pd.DataFrame:
    url = f"{BASE_URL}/instruments"
    data = _get_json(url, params={"authKey": authkey}, timeout=timeout, max_retries=max_retries)

    if isinstance(data, dict):
        for k in ["instruments", "Instruments", "data", "Data"]:
            if k in data and isinstance(data[k], list):
                data = data[k]
                break

    if not isinstance(data, list):
        raise RuntimeError(f"Uventet instruments-respons: {type(data)}")

    df = pd.json_normalize(data)
    low = {c.lower(): c for c in df.columns}
    tcol = low.get("ticker")
    idcol = low.get("insid") or low.get("ins_id") or low.get("id")
    if not tcol or not idcol:
        raise RuntimeError(f"Fant ikke ticker/insId i instruments. Kolonner: {df.columns.tolist()[:40]}")
    out = df[[tcol, idcol]].rename(columns={tcol: "ticker", idcol: "ins_id"})
    out["ticker"] = out["ticker"].astype(str).str.strip()
    out["ins_id"] = pd.to_numeric(out["ins_id"], errors="coerce")
    out = out.dropna(subset=["ins_id"]).copy()
    out["ins_id"] = out["ins_id"].astype(int)
    return out.drop_duplicates(subset=["ticker"])


def _normalize_kpi_history_payload(payload: Any, reporttype: str) -> Any:
    """
    Returnerer "beste" representasjon uten å miste instrument-info.
    NB: Hvis payload er dict med reportsYear/reportsQuarter/reportsR12, må vi beholde dict'en.
    """
    # Ny shape: dict med buckets -> behold dict (vi trenger instrument->insId)
    if isinstance(payload, dict) and any(k in payload for k in ("reportsYear", "reportsQuarter", "reportsR12")):
        return payload

    # Eldre dict-wrappers som inneholder liste
    if isinstance(payload, dict):
        for k in ["data", "Data", "instruments", "Instruments", "items", "Items"]:
            if k in payload and isinstance(payload[k], list):
                return payload[k]

    return payload

    # eldre dict-wrappers
    if isinstance(payload, dict):
        for k in ["data", "Data", "instruments", "Instruments"]:
            if k in payload and isinstance(payload[k], list):
                return payload[k]
    return payload


def _parse_kpi_history_payload(payload: Any, reporttype: str) -> List[Dict[str, Any]]:
    rows: List[Dict[str, Any]] = []
    payload = _normalize_kpi_history_payload(payload, reporttype)

    def _ins_id(obj: Dict[str, Any]) -> Any:
        iid = (
            obj.get("insId")
            or obj.get("ins_id")
            or obj.get("InsId")
            or obj.get("instrumentId")
            or obj.get("instrument_id")
            or obj.get("id")
        )
        if iid is not None:
            return iid
        inst = obj.get("instrument")
        if isinstance(inst, dict):
            return inst.get("insId") or inst.get("ins_id") or inst.get("InsId") or inst.get("id")
        return None

    def _points(obj: Dict[str, Any]) -> List[Any]:
        for k in ("values", "history", "data", "items", "points", "kpiHistory", "kpi_history"):
            v = obj.get(k)
            if isinstance(v, list):
                return v
        return []

    def _date_from_yp(y: Any, p: Any) -> Any:
        # values-punkter fra Borsdata har ofte {y,p,v}
        if y is None:
            return None
        try:
            yy = int(y)
        except Exception:
            return None

        # Year: bruk alltid 31.12
        if reporttype == "year":
            return f"{yy}-12-31"

        # Quarter/R12: bruk p hvis mulig
        if p is None:
            return f"{yy}-12-31"
        try:
            pp = int(p)
        except Exception:
            return f"{yy}-12-31"

        # Hvis p ser ut som kvartal (1-4): bruk kvartalsslutt
        if 1 <= pp <= 4:
            month = 3 * pp
            return (pd.Timestamp(yy, month, 1) + pd.offsets.MonthEnd(0)).date().isoformat()

        # Hvis p ser ut som måned (1-12): bruk måneds-slutt
        if 1 <= pp <= 12:
            month = pp
            return (pd.Timestamp(yy, month, 1) + pd.offsets.MonthEnd(0)).date().isoformat()

        # fallback
        return f"{yy}-12-31"

    def _date_val(pt: Dict[str, Any]):
        d = (
            pt.get("d")
            or pt.get("date")
            or pt.get("reportEndDate")
            or pt.get("reportDate")
            or pt.get("periodEnd")
            or pt.get("period_end")
            or pt.get("t")
            or pt.get("time")
            or pt.get("reportTime")
        )
        if d is None and ("y" in pt):
            d = _date_from_yp(pt.get("y"), pt.get("p"))
        v = pt.get("v") if "v" in pt else pt.get("value", pt.get("val"))
        return d, v

    # CASE 1: list (inkl. kpisList => list med objekter)
    if isinstance(payload, list):
        for obj in payload:
            if not isinstance(obj, dict):
                continue
            iid = _ins_id(obj)
            pts = _points(obj)

            # noen ganger er obj selv et punkt
            if not pts and any(k in obj for k in ("d","date","value","v","y","p","reportEndDate","reportDate","reportTime")):
                d, v = _date_val(obj)
                rows.append({"ins_id": iid, "date": d, "value": v})
                continue

            for pt in pts:
                if isinstance(pt, dict):
                    d, v = _date_val(pt)
                    rows.append({"ins_id": iid, "date": d, "value": v})
        return rows

    # CASE 2: dict med buckets (fallback)
    if isinstance(payload, dict) and any(k in payload for k in ("reportsYear", "reportsQuarter", "reportsR12")):
        inst = payload.get("instrument") if isinstance(payload.get("instrument"), dict) else {}
        iid = (inst.get("insId") or inst.get("id")) if isinstance(inst, dict) else None
        key_map = {"year": "reportsYear", "quarter": "reportsQuarter", "r12": "reportsR12"}
        bucket = payload.get(key_map.get(reporttype, ""), [])
        if isinstance(bucket, list):
            for pt in bucket:
                if isinstance(pt, dict):
                    d, v = _date_val(pt)
                    rows.append({"ins_id": iid, "date": d, "value": v})
        return rows

    return rows

